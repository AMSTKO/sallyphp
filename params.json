{"name":"Sallyphp","tagline":"Sally : PHP HMVC Framework","body":"SallyPHP\r\n========\r\n\r\nSallyPHP est un framework permettant de développer des applications web sur les modèles MVC et HMVC (hierarchical model–view–controller). Il fournit des outils simples, légés et rapides à prendre en main afin de créer des applications riches et structurées.\r\n\r\n## Hello world!\r\n\r\nCaractéristes de l'exemple fournit avec les sources :\r\n\r\n- Structure HMVC (répertoire modules, contenant plusieurs sous structures MVC)\r\n- Près à être utilisé en local (http://127.0.0.1/sallyphp/index.php/index)\r\n\r\nConfiguration Apache :\r\n\r\n    Alias /sallyphp \"/var/www/sallyphp/public\"\r\n    <Directory \"/var/www/sallyphp/public\">\r\n        SetEnv environnement local\r\n    </Directory>\r\n\r\nSommaire\r\n--------\r\n\r\n- [Structure](#structure)\r\n- [Inventaire](#inventaire)\r\n- [Notes](#notes)\r\n- [Sally](#sally)\r\n- [Sally_Controller](#sally_controller)\r\n- [Sally_Model](#sally_model)\r\n- [Sally_View](#sally_view)\r\n- [Sally_Layout](#sally_layout)\r\n- [Sally_Acl](#sally_acl)\r\n- [Sally_Db](#sally_db)\r\n- [Sally_Request](#sally_request)\r\n- [Sally_Helper](#sally_helper)\r\n- [Sally_Session](#sally_session)\r\n- [Sally_Trafficker](#sally_trafficker)\r\n- [Sally_Rijndael](#sally_rijndael)\r\n- [Sally_PHPMailer](#sally_phpmailer)\r\n- [License](#license)\r\n\r\nStructure\r\n---------\r\n\r\n    application/\r\n      helpers/\r\n      layouts/ (templates)\r\n      models/\r\n      modules/\r\n        admin/\r\n          controllers/\r\n          view/\r\n        cli/\r\n          controllers/\r\n        site/\r\n          controllers/\r\n          view/\r\n      traffickers/\r\n    public/\r\n      static/ (img, js, css...)\r\n    sallyphp/ (class of Sally)\r\n\r\n\r\nInventaire\r\n----------\r\n\r\nListe des class auxquelles vous pourrez avoir besoin au cours de votre développement.\r\n\r\n    $sally = Sally::getInstance();\r\n    $acl = Sally_Acl::getInstance();\r\n    $db = Sally_Db::getInstance();\r\n    $request = Sally_Request::getInstance();\r\n    $layout = Sally_Layout::getInstance();\r\n    $helper = Sally_Helper::getInstance();\r\n    $session = Sally_Session::getInstance();\r\n    $trafficker = Sally_Trafficker::getInstance();\r\n\r\n**Divers**\r\n\r\n    $rijndael = Sally_Rijndael::getInstance();\r\n    $PHPMailer = Sally_PHPMailer::getInstance();\r\n\r\nNotes\r\n-----\r\n\r\n**slash devant éléments à charger**\r\n\r\nEn ajoutant un slash devant le nom d'un élément à charger (helper, view, model, layout ou trafficker) celui ci sera cherché dans son répertoire à la racine de l'application. Sinon il sera cherché dans son répertoire depus le module demandé par la requête.\r\n\r\n\r\nSally\r\n-----\r\n\r\n**Récupérer l'instance**\r\n\r\n    $sally = Sally::getInstance();\r\n\r\n**Récupérer et écraser la réponse de la requête**\r\n\r\n*Retourner le contenu qui sera envoyé au navigateur :*\r\n\r\n    $sally->getOut();\r\n\r\n*Écraser ce contenu pour renvoyer autre chose :*\r\n\r\n    $sally->setOut('your content...');\r\n\r\nExemple d'utilisation : Dans un *trafficker*, avant de délivrer le contenu au navigateur, vous pourriez retirer tous les espaces d'indendations pour économiser de la bande passante.\r\n\r\n    class MyTrafficker extends Sally_Trafficker_Abstract\r\n    {\r\n      function preDelivery()\r\n      {\r\n        $sally->setOut(preg_replace('/\\s\\s+/', ' ', $sally->getOut());\r\n      }\r\n    }\r\n\r\n**Récupérer un retour de controleur**\r\n\r\nLes controleurs ont la possibilité de retourner des valeurs. Vous pourriez récupérer ces valeurs dans un *trafficker* pour les modifier (ajouter un token... exemple disponible sur la documentation du trafficker).\r\n\r\n    $sally->getDataBack();\r\n\r\n\r\nSally_Controller\r\n----------------\r\n\r\n**__contruct**\r\n\r\nSi vous ajoutez votre méthode __contruct au controleur alors il faudra faire référence au contructeur parent :\r\n\r\n    class IndexController extends Sally_Controller\r\n    {\r\n      public function __construct()\r\n      {\r\n        parent::__construct();\r\n      }\r\n    }\r\n\r\n**Charger un model**\r\n\r\n    $this->model('/user'); // return class object\r\n\r\n**Transmettre des variables dans la vue principale**\r\n\r\n    $this->view->setData('name1', 'value1');\r\n\r\n    // or\r\n\r\n    $this->view->setData(array(\r\n      'name1' => 'value1',\r\n      'name2' => 'value2'\r\n    ));\r\n\r\n    // in view file : echo $name1; // display value1\r\n\r\n**Charger une vue**\r\n\r\n    echo $this->view->load('/sidebar', array(\r\n      'login' => 'Mr.Ping'\r\n    ));\r\n\r\n    // in view file : echo $login; // display Mr.Ping\r\n\r\n**Charger un helper**\r\n\r\n    $this->helper('/tostrong');\r\n\r\n**Redirection**\r\n\r\n    $this->redirect('http://google.fr');\r\n\r\n**Rediriger vers une autre action dans la même requête**\r\n\r\n    $this->forward($action, $controleur, $module);\r\n\r\nIl est nécessaire de préciser au moins l'action (controleur et module seront ceux en cours). Exemple :\r\n\r\n    class IndexController extends Sally_Controller\r\n    {\r\n      public function index()\r\n      {\r\n        $this->forward('maintenance', 'erreur');\r\n      }\r\n    }\r\n\r\nEn accédant à l'index il y aura une redirection transparente vers l'action \"maintenance\" du controleur \"erreur\".\r\n\r\n\r\nSally_Model\r\n-----------\r\n\r\n**Charger un model depuis un model**\r\n\r\n    $this->load('/other_model'); // return class object\r\n\r\n\r\nSally_View\r\n----------\r\n\r\n**Récupérer l'instance**\r\n\r\n    $view = Sally_View::getInstance();\r\n\r\n**Désactiver l'appel automatique d'une vue pour l'action du controleur**\r\n\r\n    $view->disableControllerView();\r\n\r\n**Vérifier si l'appel automatique d'une vue n'a pas été désactivé**\r\n\r\n    $view->controllerViewIsEnabled(); // Boolean\r\n\r\n\r\nSally_Layout\r\n------------\r\n\r\n**Récupérer l'instance**\r\n\r\n    $layout = Sally_Layout::getInstance();\r\n\r\n**Définir un layout**\r\n\r\n    $layout->set('/home');\r\n\r\n**Désactiver le layout**\r\n\r\n    $layout->disableLayout();\r\n\r\n**Vérifier si le layout n'a pas été désactivé**\r\n\r\n    $layout->isEnabled(); // Boolean\r\n\r\n**Vérifier si un layout est définit**\r\n\r\n    $layout->isDefined(); // Boolean\r\n\r\n**Transmettre des variables dans le layout**\r\n\r\n    $>layout->setData('name1', 'value1');\r\n\r\n    // or\r\n\r\n    $layout->setData(array(\r\n      'name1' => 'value1',\r\n      'name2' => 'value2'\r\n    ));\r\n\r\n    // in view file : echo $name1; // display value1\r\n\r\n\r\nSally_Acl\r\n---------\r\n\r\n**Récupérer l'instance**\r\n\r\n    $acl = Sally_Acl::getInstance();\r\n\r\n**Ajouter des rôles**\r\n\r\n    $acl->addRole('guest');\r\n    $acl->addRole('user', 'guest');\r\n\r\n**Ajouter des ressources**\r\n\r\n    $acl->AddRessource('public');\r\n    $acl->AddRessource('account');\r\n\r\n**Ajouter des autorisations**\r\n\r\n    $acl->allow('guest', 'public');\r\n    $acl->allow('guest', 'account', array('signin', 'signup', 'request'));\r\n    $acl->allow('user', 'account');\r\n\r\n**Ajouter une restriction**\r\n\r\n    $acl->deny('guest', 'public', array('action_name'));\r\n\r\n**Vérifier si un utilisateur a le droit d'accéder à une ressource**\r\n\r\n    if (!$acl->isAllowed($role_name, $ressource_name, $action_name)) {\r\n      exit;\r\n    }\r\n\r\n\r\nSally_Db\r\n--------\r\n\r\n**Récupérer l'instance**\r\n\r\n    $db = Sally_Db::getInstance();\r\n\r\n**SGBD pris en charges**\r\n\r\n- Mysql (avec PDO)\r\n\r\n**Ajouter une connexion à une base de données**\r\n\r\n    $db->add(array(\r\n      'type' => 'mysql_pdo',\r\n      'host' => '127.0.0.1',\r\n      'dbname' => 'db_name',\r\n      'user' => 'db_user',\r\n      'passwd' => 'db_pasword'\r\n    ));\r\n\r\n**Ajouter d'autres bases de données**\r\n\r\nSally_Db gère les multi-connexions avec PDO. Il suffit d'ajouter le nom de la connexion lors de l'ajout. Par defaut le nom de la connexion est *default*\r\n\r\n    $db->add(array(\r\n      'name' => 'principal'\r\n      'type' => 'mysql_pdo',\r\n      'host' => '127.0.0.1',\r\n      'dbname' => 'db_name',\r\n      'user' => 'db_user',\r\n      'passwd' => 'db_pasword'\r\n    ));\r\n\r\n    $db->add(array(\r\n      'name' => 'other'\r\n      'type' => 'mysql_pdo',\r\n      'host' => '192.168.1.12',\r\n      'dbname' => 'db_name',\r\n      'user' => 'db_user',\r\n      'passwd' => 'db_pasword'\r\n    ));\r\n\r\n**Récupérer une instance de connexion**\r\n\r\nSans argument il vous sera renvoyé la première connexion, *default*.\r\n\r\n    $db = Sally_Db::getConnection();\r\n\r\nSinon il suffit de préciser le nom de la connexion.\r\n\r\n    $db = Sally_Db::getConnection('other');\r\n\r\n**Exemple de requête avec PDO**\r\n\r\n    public function getEmail($user)\r\n    {\r\n      $db = Sally_Db::getConnection();\r\n      $stmt = $db->prepare('SELECT email FROM users WHERE id = :id LIMIT 1');\r\n      $stmt->execute(array('id' => $user));\r\n      $result = $stmt->fetch();\r\n      return $result['email'];\r\n    }\r\n\r\n\r\nSally_Request\r\n-------------\r\n\r\nLes requêtes peuvent être faites sous différentes formes :\r\n\r\n- /module/controller/action\r\n- /controller/action (en définissant le module par defaut dans la conf)\r\n- /controller/action/dataName1/dataValue1/dataName2/dataValue2\r\n\r\n**Récupérer l'instance**\r\n\r\n    $request = Sally_Request::getInstance();\r\n\r\n**Récupérer les valeurs des données passées dans la requête**\r\n\r\n    $request->getRequest('dataName1'); // False si inexistante\r\n\r\n**Écraser des valeurs passées dans la requête**\r\n\r\n    $request->setRequest('dataName1', 'dataValue1');\r\n\r\n**Récupérer des données $_POST**\r\n\r\n    $request->getPost('name'); // value or false\r\n\r\n**Redéfinir le module**\r\n\r\n    $request->setModule('module_name');\r\n\r\n**Redéfinir le controleur**\r\n\r\n    $request->setController('controller_name');\r\n\r\n**Redéfinir l'action**\r\n\r\n    $request->setAction('action_name');\r\n\r\n**Récupérer le nom du module en cours**\r\n\r\n    $request->getModule();\r\n\r\n**Récupérer le nom du controleur en cours**\r\n\r\n    $request->getController();\r\n\r\n**Récupérer le nom de l'action en cours**\r\n\r\n    $request->getAction();\r\n\r\n\r\nSally_Session\r\n-------------\r\n\r\nSally créer un cookie dont la valeur est cryptée avec l'algo Rijndael en 128b (MCRYPT_RIJNDAEL_128). La valeur correspond à un tableau sérialisé contenant vos informations.\r\n\r\n**Récupérer l'instance**\r\n\r\n    $session = Sally_Session::getInstance();\r\n\r\n**Savoir si l'utilisateur avait déjà le cookie**\r\n\r\n    $session->hasCookie(); // Boolean\r\n\r\n**Définir une valeur dans le cookie**\r\n\r\n    $session->set('logged', 1);\r\n\r\n**Récupérer une valeur du cookie**\r\n\r\n    $session->get('logged');\r\n\r\n**Récupérer le tableau contenant toutes les valeurs du cookie**\r\n\r\n    $session->getContent();\r\n\r\n**Écraser tous le contenu du cookie**\r\n\r\n    $session->setContent();\r\n\r\n    // ou\r\n\r\n    $session->setContent(array(\r\n      'logged' => 1,\r\n      'username' => 'Pingoo'\r\n    ));\r\n\r\n\r\nSally_Helper\r\n------------\r\n\r\nLes helpers sont de basiques fonctions PHP appelable n'importe ou.\r\n\r\n**Récupérer l'instance**\r\n\r\n    $helper = Sally_Helper::getInstance();\r\n\r\n**Charger un helper**\r\n\r\n    $helper->load('helper_name');\r\n\r\n**Exemple de helper : toStrongHelper.php**\r\n    \r\n    <?php\r\n    function toStrong($text)\r\n    {\r\n      echo '<strong>' . $text . '</strong>';\r\n    }\r\n\r\n\r\nSally_Trafficker\r\n----------------\r\n\r\nLe trafiquant permet d'agir à 2 endroits :\r\n\r\n- avant l'appel d'un controleur;\r\n- avant de retourner le contenu de la requête;\r\n\r\n**avant l'appel d'un controleur : preDeal() {}**\r\n\r\nIntercepter la requête au début du traitement.\r\n\r\n- redéfinir le nom du module, du controleur ou de l'action pour afficher une autre page que prévu;\r\n- vérifier les droits ACL et faire un choix d'affichage ou redirection à ce moment la;\r\n- définir un layout en fonction de l'utilisateur;\r\n- afficher une page d'erreur;\r\n- ...\r\n\r\n**avant de retourner le contenu de la requête : preDelivery() {}**\r\n\r\nTrafiquer le retour de la requête au dernier moment.\r\n\r\n- ajouter une token;\r\n- ajouter une information (temps de traitement...);\r\n- ...\r\n\r\n**Récupérer l'instance**\r\n\r\n    $trafficker = Sally_Trafficker::getInstance();\r\n\r\n**Charger un trafiquant**\r\n\r\n    $trafficker->add('my');\r\n\r\n**Exemple de trafiquant : MyTrafficker.php**\r\n\r\nJe vais avoir beaucoup de requêtes ajax sur mon projet. Alors je décide que chaque controleur aura une action nommée \"request\" qui permettra de traiter ces requêtes. Dans un premier temps (preDeal) on désactive le layout et la vue par defaut pour l'action \"request\". Une fois la requête prête à être renvoyée (preDelivery) on ajoute des valeurs (ici un token).\r\n\r\n    class MyTrafficker extends Sally_Trafficker_Abstract\r\n    {\r\n      function __construct()\r\n      {\r\n        $this->layout = Sally_Layout::getInstance();\r\n        $this->view = Sally_View::getInstance();\r\n        $this->request = Sally_Request::getInstance();\r\n      }\r\n\r\n      function preDeal()\r\n      {\r\n        $this->layout->set('/home');\r\n        if ($this->request->getAction() == 'request') {\r\n          $this->layout->disableLayout();\r\n          $this->view->disableControllerView();\r\n        }\r\n      }\r\n\r\n      function preDelivery()\r\n      {\r\n        if ($this->request->getAction() == 'request') {\r\n          $sally = Sally::getInstance();\r\n          $sally->setOut(json_encode(array_merge(array(\r\n            'token' => 12456\r\n          ), $sally->getDataBack())));\r\n        }\r\n      }\r\n    }\r\n\r\n\r\nSally_Rijndael\r\n--------------\r\n\r\n**Récupérer l'instance**\r\n\r\n    $rijndael = Sally_Rijndael::getInstance();\r\n\r\n**Définir une clef de cryptage**\r\n\r\n    $rijndael->setKey('your key');\r\n\r\n**Crypter des données**\r\n\r\n    $rijndael->encrypt('data');\r\n\r\n**Décrypter des données**\r\n\r\n    $rijndael->decrypt('dataCrypted');\r\n\r\n\r\nSally_PHPMailer\r\n--------------\r\n\r\nPour d'avantage de documentation rendez-vous sur https://github.com/Synchro/PHPMailer\r\n\r\n**Récupérer l'instance**\r\n\r\n    $PHPMailer = Sally_PHPMailer::getInstance();\r\n\r\n**Configuration**\r\n\r\n    $PHPMailer->IsSMTP();\r\n    $PHPMailer->Host = 'in.mailjet.com';\r\n    $PHPMailer->Port = 587;\r\n    $PHPMailer->SMTPAuth = true;\r\n    $PHPMailer->Username = 'username';\r\n    $PHPMailer->Password = 'password';\r\n    $PHPMailer->SMTPSecure = 'tls';\r\n\r\n**Envoyer un e-mail**\r\n\r\n    $PHPMailer->From = 'from@example.com';\r\n    $PHPMailer->AddAddress('ellen@example.com');\r\n    $PHPMailer->IsHTML(true);\r\n    $PHPMailer->Subject = 'Here is the subject';\r\n    $PHPMailer->Body    = 'This is the HTML message body <b>in bold!</b>';\r\n    $PHPMailer->AltBody = 'This is the body in plain text for non-HTML mail clients';\r\n    $PHPMailer->Send(); // Boolean\r\n\r\n\r\nLicense\r\n-------\r\n\r\n**New BSD License**\r\n\r\nCopyright (c) 2013, Jonathan Amsellem.\r\n\r\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\n\r\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\r\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\r\nNeither the name of Jonathan Amsellem nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\r\n\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}